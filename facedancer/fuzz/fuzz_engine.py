#!/usr/bin/env python
'''
Usage:
    fuzz_engine -s <stage-file> [-d <pre,post>] [-c <count>] [-k <options>]

Options:
    -c --count <count>                  stage count (e.g. how many times a stage might repeat
                                        before mutating) [default: 2]
    -d --disconnect-delays=<pre,post>   number of seconds to wait in the post_test before and after
                                        disconnecting the device (might be necessary in order for
                                        failures to be matched with the correct test) [default: 0.0,0.0]
    -k --kitty-options <options>        options for the kitty fuzzer, use -k -h to get a full list
    -s --stage-file <stage-file>        path to stage trace from fd emulation run
'''
import docopt
from kitty.remote.rpc import RpcServer
from kitty.fuzzers import ClientFuzzer
from kitty.targets import ClientTarget
from kitty.interfaces import WebInterface
from kitty.model import GraphModel
from kitty.model import Template, Meta, String, UInt32

from templates import audio, cdc, enum, generic, hid, hub, mass_storage
from templates import smart_card

from controller import FDController


def enumerate_templates(module):
    '''
    :return: a list of templates that are in a module
    '''
    member_names = sorted(dir(module))
    templates = {}
    for name in member_names:
        member = getattr(module, name)
        if isinstance(member, Template):
            templates[member.name] = member
        elif isinstance(member, dict):
            for k, item in member.items():
                if isinstance(item, Template):
                    templates[item.name] = item
        elif isinstance(member, list):
            for item in member:
                if isinstance(item, Template):
                    templates[item.name] = item
    return templates


def get_stages(stage_file):
    '''
    Get a dictionary (stage:count) from a stage file

    :param stage_file: filename with stage list (generated by fd2stages)
    :return: dictionary of stage:count
    '''
    with open(stage_file, 'r') as f:
        stages = [l.rstrip() for l in f.readlines()]
    stage_count = {}
    for stage in stages:
        stage_count[stage] = stages.count(stage)
    return stage_count


def add_stage(g, stage, template, count):
    '''
    Add a stage to the session graph

    :param g: the GraphModel object
    :param stage: stage name
    :param template: the actual template
    :param count: the stage count

    :example:

        for the call add_stage(g, 'X', x, 4) we will create the following
        graph:

        ::

            x
            p1 -> x
            p1 -> p2 -> x
            p1 -> p2 -> p3 -> x
    '''
    g.connect(template)
    pseudos = [
        # workaround for a PseudoTemplate bug in kitty 0.6.9
        # TODO: move to PseudoTemplate in next kitty version
        Template(
            name=stage,
            fields=Meta(fields=[
                String(value=stage),
                UInt32(value=i)
            ]),
            fuzzable=False
        ) for i in range(count - 1)
    ]
    if pseudos:
        g.connect(pseudos[0])
        for i in range(len(pseudos) - 1):
            g.connect(pseudos[i], pseudos[i + 1])
            g.connect(pseudos[i], template)
        g.connect(pseudos[-1], template)


def get_model(options):
    '''
    Get the data model

    :param options: options
    :return: session model
    '''
    stage_file = options['--stage-file']
    stages = get_stages(stage_file)
    templates = {}
    templates.update(enumerate_templates(audio))
    templates.update(enumerate_templates(cdc))
    templates.update(enumerate_templates(enum))
    templates.update(enumerate_templates(generic))
    templates.update(enumerate_templates(hid))
    templates.update(enumerate_templates(hub))
    templates.update(enumerate_templates(mass_storage))
    templates.update(enumerate_templates(smart_card))
    g = GraphModel('usb model (%s)' % (stage_file))
    for stage in stages:
        if stage in templates:
            stage_template = templates[stage]
            stage_count = min(stages[stage], int(options['--count']))
            add_stage(g, stage, stage_template, stage_count)
    return g


def get_controller(options):
    '''
    Get the controller

    :param options: options
    :return: controller
    '''
    try:
        pre_disconnect_delay, post_disconnect_delay = \
            [float(f) for f in options['--disconnect-delays'].split(',')]
    except ValueError:
        msg = 'Please specify the --disconnect_delays as two comma-separated floats'
        raise Exception(msg)
    return FDController(pre_disconnect_delay, post_disconnect_delay)


def get_fuzzer(options=None):
    '''
    Get fuzzer (non-remote)

    :param options: options
    :return: fuzzer
    '''
    local_options = {
        '--kitty-options': None,
        '--stage-file': None,
        '--count': '2',
        '--disconnect-delays': '0.0,0.0'
    }
    local_options.update(options)
    fuzzer = ClientFuzzer(name='facedancer', option_line=local_options['--kitty-options'])
    fuzzer.set_interface(WebInterface())

    target = ClientTarget(name='USBTarget')
    target.set_controller(get_controller(local_options))
    target.set_mutation_server_timeout(10)

    model = get_model(local_options)
    fuzzer.set_model(model)
    fuzzer.set_target(target)
    return fuzzer


def main():
    options = docopt.docopt(__doc__)
    fuzzer = get_fuzzer(options)
    remote = RpcServer(host='localhost', port=26007, impl=fuzzer)
    remote.start()


if __name__ == '__main__':
    main()
